Concepts
""""""""

.. _Interpreter:

Interpreter
-----------

As an interpreter, one or more commands with their arguments can be issued on a
line. The commands will be executed in sequence. If any command fails,
generally the interpreter will abandon the rest of the commands on the line and
return to the prompt. The interpreter mode prompt is a right-arrow (``>``) but
will have a number to the left of it (e.g., ``1>``) if in a nested interpreter
sublevel.

.. _Nested interpreter sublevel:

Nested interpreter sublevel
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :ref:`interpret <interpret>` command can be used to enter a nested
interpreter sublevel, an interpreter nested within the previous level of
interpreter.

State is inherited by a nested interpreter sublevel from the previous level of
interpreter.

Some state persists in the previous level of interpreter when the nested
interpreter sublevel ends and some is lost.

When the sublevel ends (via :ref:`bye <bye>` or ``Ctrl-D``),

-  :ref:`FUNC <FUNC>` definitions made in the sublevel persist.
-  :ref:`Tuple <Tuple_Variables>` definitions made in the sublevel persist.
-  :ref:`Constant <Constants>` definitions made in the sublevel are lost.

.. _Main interpreter:

Main interpreter
~~~~~~~~~~~~~~~~

The instance of the interpreter presented to the user upon program invocation
is called the **main interpreter** to distinguish it from :ref:`nested
interpreter sublevels <Nested_interpreter_sublevel>` and from (possibly
multiple) interpreter instances created in :ref:`server mode <Server_mode>`.

.. _Server mode:

Server mode
-----------

Ublu can launch multiple TCP/IP port servers that accept connections and bind
them to individual :ref:`interpreter  <Interpreter>` sessions.  This allows
remote applications such as web applications to execute Ublu commands and
receive their output. The default listener port is 43860. See the ``server``
command.

The ``server`` command can also be used to interpret a single :ref:`execution
block  <Execution_blocks>` for each connection and then disconnect at the end
of interpreting the block. This allows the user to connect to a "canned
program" instead of gaining access to the full interpreter.

.. _Commandline:

Commandline
-----------

Invoked as a command line application with or more commands following the
:ref:`invocation  <Invocation>` on the shell command line, the commands and
their arguments are processed as in the interpreter, then the application
exits. If one of the commands is :ref:`interpret <interpret>`, then the
application continues to run until that interpreter exits when that interpreter
encounters the ``bye`` or :ref:`exit <exit>` command. ``exit`` always exits,
but ``bye`` only unnests one interpreter level. If that interpreter is the
:ref:`main interpreter  <Main_interpreter>`, Ublu exits.

.. _Input:

Input
-----

Input for the :ref:`main interpreter  <Main_interpreter>` can come from the
console or from standard input when Ublu is invoked using some form of shell
redirection, e.g., shell pipes ( ``|`` ) or "here documents" ( ``<<`` ).

When interpreter input comes from standard in, prompting is suppressed.

In :ref:`server mode  <Server_mode>`, input comes from the network socket and
prompting is suppressed.

.. _Output:

Output
------

In :ref:`interpreter  <Interpreter>` and :ref:`commandline  <Commandline>`
mode, command output of Ublu is written to standard out, with the exception of
the following which are written to standard error:

-  error and exception mesages
-  some user informational messages which appear in interpretive mode,
   such as the initial version message, copyright message
-  all help and usage messages
-  the prompt

When automating system tasks, it may be helpful to redirect stderr from the
shell command line via ``2>/dev/null`` to discard miscellaneous interpreter
informational output. This, however, discards error messages as well.

In :ref:`server mode  <Server_mode>`, Ublu standard out is connected the
network socket. However, Ublu standard error output remains attached to
the invoking interpreter's standard error. This makes the :ref:`main
interpreter <Main_interpreter>` a monitor of errors occurring in
server threads.

.. _Executing commands from a file:

Executing commands from a file
------------------------------

Interpretation of a text file of :ref:`commands  <Commands>` and
:ref:`functions  <Functions>` is performed via the command ``include``.

Launch your application from a shell script autogenerated via ``gensh``
-----------------------------------------------------------------------

Ublu offers a command :ref:`gensh <gensh>` which autogenerates a shell
script to process arguments to your custom function via command line
switches and invoke your custom function with those arguments. This is
the Ublu model for runtime program delivery.

.. _Debugger:

Debugger
--------

The :ref:`dbug  <dbug>` command provides interactive single-step debugging of
an :ref:`execution block  <Execution_blocks>`.

.. _Parsing and syntax:

Parsing and syntax
------------------

Parsing and syntax are simplistic.

Input is parsed left-to-right, with no lookback. Each sequence of
non-whitespace characters separated from other non-whitespace by at least one
whitespace character is parsed as an element. No extra whitespace is preserved
in parsing, not even within :ref:`quoted strings <Quoted_strings>` (with the
important exception that a quoted string is always returned with a blank space
as the last character).

.. Note::
    the simplistic parser imposes one particularly arbitrary
    limitation in that within an :ref:`execution block  <Execution_blocks>` neither
    the block opener ``$[`` nor the block closer ``]$`` are allowed to appear
    inside a quoted string. If you need to have those symbols in a quoted string,
    the limitation is easy to get around, as follows::

        put -to @foo ${ $[ }$
        put -to @bar ${ $] }$
        FOR @i in @foo $[ put -from @i ]$
        FOR @i in @bar $[ put -from @i ]$

.. _Quoted strings:

Quoted strings
--------------

Quoting of strings is achieved by placing the string between two elements
**``${``** and **``}$``** . The open and close elements of a quoted string must
each be separated by at least one space from the contents of the string and
from any leading or following commands or arguments.

Whitespace between non-whitespace elements of the string is compacted
into single spaces  ``${ This     is         a quoted     string.   }$``
represents ``This is a quoted string.`` A quoted string is always
returned by the parser with a blank space at the end of it.

A quoted string can span multiple lines. When end-of-line is reached in
the interpreter after the open-quote glyph ( ``${`` ) without finding
the close-quote glyph ( ``}$`` ), then string parsing continues and the
prompt changes for any lines following until the close-quote glyph is
encountered. The string parsing continuation prompt is the open-quote
glyph surrounded in parentheses ``(${)`` .

.. Note::
    the simplistic parser imposes one particularly arbitrary
    limitation in that within an :ref:`execution block  <Execution_blocks>` neither
    the block opener ``$[`` nor the block closer ``]$`` are allowed to appear
    inside a quoted string. If you need to have those symbols in a quoted string,
    the limitation is easy to get around, as follows::

        put -to @foo ${ $[ }$
        put -to @bar ${ $] }$
        FOR @i in @foo $[ put -from @i ]$
        FOR @i in @bar $[ put -from @i ]$

.. _Tuple variables:

Tuple variables
---------------

A tuple variable is a :ref:`autoinstancing  <Tuple_autoinstancing>` name-value
pair that is either globally accessible within the given interpreter session or
made :ref:`local  <Local_variables>` to a function definition via the
:ref:`LOCAL <LOCAL>` command. Tuples are always referenced with a "@" as the
first character of their name, e.g., ``@session``. You can direct any kind of
object to a tuple with the :ref:``-to`` ``@tuplename`` `dash-command
<Dash_Command>` (adjunct to commands which support that) and retrieve the value
with ``-from   @tuplename`` (adjunct to commands which support that).

Tuples can be directly manipulated via the :ref:`put <put>` and :ref:`tuple
<tuple>` commands.

.. _Default Tuples:

Default Tuples
~~~~~~~~~~~~~~

The Ublu interpreter starts with certain tuples already defined, as
shown in the chart below:

    +--------------+-------------+--------------------------------------+
    | *name*       | *value*     | *notes*                              |
    +--------------+-------------+--------------------------------------+
    | ``@true``    | ``true``    | can be used for conditionals, etc.   |
    +--------------+-------------+--------------------------------------+
    | ``@false``   | ``false``   | can be used for conditionals, etc.   |
    +--------------+-------------+--------------------------------------+

These defaults are not constant and can be overwritten at runtime via
normal tuple manipulation.

.. _Tuple naming:

Tuple naming
~~~~~~~~~~~~

A tuple name can consist of any string of printable characters starting with
the initial ``@`` marker *except* that the name may not start with the reserved
sequence ``@///``\ *number*. A tuple name of this form (e.g., ``@///19``)
denotes a temporary variable used in function argument binding. Currently the
protection of this form of tuple name is not enforced by the interpreter.
**Unpredictable results** can occur if you use this form to name a tuple
variable.

.. _Tuple autoinstancing:

Tuple autoinstancing
~~~~~~~~~~~~~~~~~~~~

A tuple springs into being in the global tuple map when a previously
unused tuple name is used as a :ref:`destination datasink  <Datasinks>` or
as a parameter (input or output) to a :ref:`function  <Functions>`. When
autoinstanced in this fashion, the new tuple's value is ``null``.
Alternatively, you can create a tuple variable using the tuple command,
e.g. ``tuple -true @foo`` will set ``@foo`` to ``true`` if it exists
already, or will create ``@foo`` and set it to ``true`` if it does not
yet exist.

.. _Tuple stack:

Tuple stack
-----------

The system maintains a Last In, First Out (LIFO) stack of tuple variables for
programming convenience manipulated via the :ref:`lifo <lifo>` command.

A command and its dash-commands that expect tuple arguments can also take the
argument **``~``** ("tilde") which signifies "pop the tuple from the tuple
stack". An error will result if the stack is empty.

When a command references a source or destination :ref:`datasink  <Datasinks>`
via the ``-to`` or ``-from`` dash-commands, that datasink may also be **``~``**
("tilde"), meaning the source or destination is the tuple stack. Non-tuples,
e.g, strings put to a destination datasink via ``-to ~`` in this fashion are
automatically wrapped in an anonymous tuple. Hence the following session::

    > put -to ~ ${ but not a clever test }$
    > put -to ~ ${ this is a test }$
    > string -to ~ -cat ~ ~
    > put ~
    this is a test but not a clever test

Autonomic Tuple Variables
-------------------------

If the interpreter encounters a tuple variable or the tuple stack pop
symbol :ref:``~`` (tilde) when it is expecting a `command  <Commands>`, it
checks the value of that variable. If the value is of a class in the
list of autonomes, that is, classes whose instances are generally passed
as the argument to the :ref:`eponymous
dash-command <Eponymous_dash-command>` of a specific Ublu
command, that command is invoked with tuple as the eponymous argument,
along with any :ref:`dash-commands  <Dash_Command>` and/or arguments which
follow. If the variable is not autonomic, the interpreter reports an
error.

Thus, the third, fourth and sixth commands of the following example
using :ref:`ifs  <ifs>` to get the size of a file in the Integrated File
System are equivalent:

::

    > as400 -to @mysys MYSYS.com myid mYpAssWoRd
    > ifs -to @f -as400 @mysys -file /home/myid/.profile
    > ifs -- @f -size
    56
    > @f -size
    56
    > lifo -push @f
    > ~ -size
    56

Autonomic tuple variables offer a useful
:ref:`object-disoriented  <Object-disoriented>` shorthand which, along with
:ref:`tuple stack  <Tuple_stack>` wizardry, one should consider avoiding in
larger programs in the interest of clarity.

-  To test whether the tuple variable ``@foo`` is autonomic, use
   ``tuple -autonomic @foo``
-  To display whether the tuple variable ``@foo`` is autonomic, use
   ``tuple -autonome @foo``
-  To display a list of all autonomic classes and the Ublu commands they
   invoke, use ``tuple -autonomes``

.. _Numbers:

Numbers
-------

Numbers are signed integers and generally can be input as decimal, hex (0x00),
or octal (000).

.. admonition::
    See also
    
    the :ref:`num  <num>` command.

.. _Plainwords:

Plainwords
----------

Any whitespace-delimited sequence of non-whitespace characters provided as an
argument to a command or dash-command  or function is a *plainword*. A
plainword can be used in most cases to represent a number or a single
whitespace-delimited textual item where a :ref:`tuple variable
<Tuple_Variables>` or :ref:`quoted string  <Quoted_strings>` would have to be
used to contain longer whitespace-including strings of text.

.. _Constants:

Constants
---------

Constants are created via the :ref:`const  <const>` command. Constants have a
string value. The name of a constant has the form ``*somename`` and can be used
as the :ref:`argument  <Argument>` to a :ref:`command  <Command>` or
:ref:`dash-command  <Dash_Command>` where the syntax notation represent the
argument as ``~@{something}`` and only in such position. Constants are not
expanded within quoted strings.  Constants cannot be used as the argument to a
``-from`` or ``-to`` dash-command. :ref:`Plainwords  <Plainwords>` resembling
constants, i.e., starting with an asterisk \* are not mistaken for constants if
they have not been defined as such.

Constants defined in an interpreter level appear in its :ref:`nested
interpreter sublevels <Nested_interpreter_sublevel>`. However,
constants defined in nested interpreter sublevels do not persist into
the previous interpreter level.

.. _Execution blocks:

Execution blocks
----------------

An **execution block** is a body of commands enclosed between the block
opener ``$[`` and the block closer ``]$`` . Execution blocks are used in
:ref:`functor  <Functors>` declarations (callable routines) via the
:ref:`FUN <FUN>` command and with conditional control flow commands
such as :ref:`FOR <FOR>` and :ref:`IF - THEN - ELSE <IF>` to
express the limit of a code phrase in a condition.::

    IF @varname THEN $[ command command .. ]$ ELSE $[     command command ]$

is a generalized example of block usage.

An execution block can contain :ref:`local variable  <Local_variables>`
declarations and their use. A local variable declaration hides identically
named variables from the global context and from any enclosing block. Inner
blocks to the declaring block have access to the locals in enclosing blocks,
unless, of course, an identically named variable has been declared local to the
enclosed block.

.. Warning::
    the "comment-to-end-of-line" command :ref:`# <comment_introducer>` should
    not ever be used in an execution block! An execution block is treated as
    one command line, so the comment command will devour the rest of the block.

.. Note::
    the simplistic parser imposes one particularly arbitrary
    limitation in that within an :ref:`execution block  <Execution_blocks>` neither
    the block opener ``$[`` nor the block closer ``]$`` are allowed to appear
    inside a quoted string. If you need to have those symbols in a quoted string,
    the limitation is easy to get around, as follows::

        put -to @foo ${ $[ }$
        put -to @bar ${ $] }$
        FOR @i in @foo $[ put -from @i ]$
        FOR @i in @bar $[ put -from @i ]$

An execution block may span several lines, however, the opening bracket (
``$[`` ) of the block *must* appear on the same line with and directly after
the conditional control flow command operating upon it.

Execution blocks may be nested.

In the :ref:`Tips and Tricks  <Tips_and_Tricks>` section of this document is an
example which will :ref:`get a list of active interactive jobs and search that
list for specific jobs <Get_a_list_of_active_interactive_jobs>`.

.. _Local variables:

Local variables
~~~~~~~~~~~~~~~

An execution block can have local :ref:`tuple variables <Tuple_Variables>`
declared via the :ref:`LOCAL <LOCAL>` command whose names hide variables of the
same name which may exist outside the execution block. Locals disappear at the
end of the block in which they are declared.

Local variables can be used safely even when a global tuple variable
coincidentally of the same name is passed in as a function argument; no
collision results, and both the local and the function argument can be
referenced.

.. admonition::
    example

    ::

        FUNC foo ( a ) $[
            LOCAL @a
            put -to @a ${ inner @a }$
            put -n -s ${ outer a: }$ put -from @@a
            put -n -s ${ local a: }$ put -from @a
        ]$
        put -to @a ${ outer @a }$
        foo ( @a )
        outer a:  outer @a
        local a:  inner @a

.. _Functors:

.. _Functors:

Functors
--------

A functor is an anonymous :ref:`execution block  <Execution_blocks>` created
via :ref:`FUN <FUN>` which can then be stored in :ref:`tuple variable
<Tuple_Variables>` and invoked via :ref:`CALL <CALL>` and/or associated with a
name entry in the function dictionary via ``defun``. Arguments can be passed to
the functor. Arguments are call-by-reference; the resolution of these arguments
is discussed under :ref:`Function Parameter Binding
<Function_Parameter_Binding>`.

.. _Functions:

Functions
---------

A function is a :ref:`functor <Functors>` associated with a name entry in the
:ref:`function dictionary  <Function_Dictionary>`, usually via ``FUNC`` but
also via the combination of :ref:`FUN <FUN>` and :ref:`defun <defun>`.

The function dictionary is searched after the list of built-in commands.
Dictionaries can be listed, saved, restored and merged via the
:ref:`dict <dict>` command. Arguments can be passed to the block. All
arguments are passed by reference, i.e., passing a :ref:`tuple
variable <Tuple_Variables>` to a function argument list passes the
tuple itself, not the tuple's value, and any alteration of the argument
alters the tuple referred to in the argument list. The resolution of
these arguments is discussed under :ref:`Function Parameter
Binding <Function_Parameter_Binding>`::

    > FUNC yadda ( a ) $[ FOR @word in @@a $[ put -n -s -from @word put ${ yadda-yadda ... }$ ]$ ]$
    > put -to @words ${ this that t'other }$
    > yadda ( @words )
    this yadda-yadda ...
    that yadda-yadda ...
    t'other yadda-yadda ...
    > dict -list
    # yadda ublu.util.Functor@1d4b0e9
    FUNC yadda ( a ) $[ FOR @word in @@a $[ put -n -s -from @word put ${ yadda-yadda ... }$ ]$  ]$

    > dict -save -to mydict
    > FUNC -delete yadda
    > dict -list

    > dict -restore -from mydict
    > dict -list
    # yadda ublu.util.Functor@14fd510
    FUNC yadda ( a ) $[ FOR @word in @@a $[ put -n -s -from @word put ${ yadda-yadda ... }$ ]$  ]$

.. admonition::
    See also

    the :ref:`FUN <FUN>` and :ref:`defun <defun>` commands.

.. _Function Parameter Binding:

Function Parameter Binding
~~~~~~~~~~~~~~~~~~~~~~~~~~

Ublu's interpreter being purely a text interpreter, performing (almost)
no tokenization during interpretation and compilation, function
parameter binding is effected by runtime rewriting ("token pasting") of
argument references (e.g., ``@@some_arg``) in the execution block to the
actual positional parameter value provided at the time the function is
called.

Arguments passed to a function or functor can be

-  :ref:`@variable <Tuple_Variables>`
-  :ref:`plainword  <Plain_words>`
-  :ref:`quoted string  <Quoted_strings>`
-  :ref:`block  <Execution_blocks>`

Arguments other than blocks or quoted strings are handled as follows:

-  If the argument provided is a simple lex, e.g., ``foo`` or ``1234``,
   or a :ref:`const  <const>`, that text is substituted uncritically at
   runtime for all references to that argument in the function body.
-  If the argument provided is a :ref:`tuple variable  <Tuple_Variables>`,
   a temporary alias for the tuple variable named in the invocation
   argument is created in a local extension to the tuple map and
   references to the argument are rewritten with the name of the
   temporary in the function's execution block.
-  If the argument is the tuple stack pop symbol ``~`` that symbol will
   appear at runtime wherever the argument is substituted in the
   function body.

Thus, in the case of a function::

    foo ( a b c ) $[ put @@a put @@b put @@c ]$

called with arguments::

    foo ( @bar woof @zotz )

is effectively seen at invocation by the interpreter as::

    $[ put @bar put woof put @zotz ]$

The temporary alias actually pasted for tuple variable arguments to
functions can be seen in the debugger.

It is perfectly acceptable to name function parameters with the same
names as command or functions. But this practice can detract from the
readability of the code, especially if using the :ref:`syntax coloring edit
modes <Syntax_coloring_edit_modes>` provided with Ublu.

.. _Function Dictionary:

Function Dictionary
-------------------

Function definitions are stored in the function dictionary.

:ref:`Interpreter  <Interpreter>` instances launched by the ``interpret``
command inherit the current function dictionary. Any additions within an
interpreter instance are lost when the instance exits back to its parent
interpreter instance.

You can view the current function dictionary or save it to a file or
:ref:`tuple variable  <Tuple_Variables>` and later restore it or merge it
with the current dictionary. See the :ref:`dict <dict>` and
:ref:`savesys  <savesys>` commands.

.. _User ID and password:

User ID and password
--------------------

You supply a user ID and a password in the argument list for any Ublu command
which accesses an AS/400 (iSeries, System/i) host, or for creating an instance
of the host using the :ref:`as400 <as400>` command so that you can employ the
``-as400`` dash-command with subsequent commands in lieu of constant repetition
of the system name, userid and password. On system operations, if the user ID
or password is incorrect, you will be prompted to enter the correct user ID
and/or password, upon completion of which the command will proceed.::

    > joblist testsys frrd oopswrong
    Please enter a valid userid for testsys: fred
    Please enter a valid password for testsys (will not echo):
    000000/QSYS/SCPF
    000736/QSYS/QSYSARB
    000737/QSYS/QSYSARB2

... etc.

The behavior of Ublu when a signon attempt fails can be modified. See the
:ref:`as400 <as400>` and :ref:`props <props>` commands for details.

DB400 database operations behave differently with regard to an incorrect userid
or password. Unlike the JTOpen systems operation code, the JTOpen JDBC driver
does not provide a programmable exit for application code to handle an
incorrect userid or password, and instead handles the exception itself by
attempting to launch a 1990's-style Java AWT window prompting for userid and
password. If your environment supports a GUI, all is well: you can supply the
correct userid and password. On the other hand, if your environment does not
support a GUI, then the operation fails and a confusing exception is thrown
complaining about the absence of a windowing system. You can avoid this
windowing behavior and just allow the operation to fail on incorrect
userid/password with an understandable exception by adding the following
connection property :ref:`dash-command  <Dash_Command>` to the string of
dash-commands for the ``db`` command::

    -property prompt false

which adds ``;prompt=false`` to the URL for the JDBC connection and disables
the windowing password prompt.
